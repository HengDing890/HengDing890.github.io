<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Heng Ding, hengding@whu.edu.cn"><title>身份证文本定位与切割算法实现 · Heng Ding (丁恒)</title><meta name="description" content="最近项目需求(身份证信息自动识别)，需要对图像中的文本进行定位与提取，这…本汪真心不懂啊. 于是乎怀着忐忑的心情去找L老板唠嗑.
[狗血剧情]本汪: 老师，这事没做过啊，不知道怎么做啊… (内心os: 您接项目能不能考虑下咱的技术储备啊)L老板: 不会啊，去学啊! 网上找下资源和论文去吧.本汪: 哦"><meta name="keywords" content="Information Retrieval, Data Mining, Deep Learning"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;border-radius:20px;"><h3 title=""><a href="/">Heng Ding (丁恒)</a></h3><div class="description"><p>科研狗 &amp; 攻城狮 | IR (信息检索) -&gt; AI (人工智能)</p></div></div></div><ul class="social-links"><li><a href="http://weibo.com/5630667316"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/HengDing890"><i class="fa fa-github"></i></a></li></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">博文</a></li><li><a href="/archives">归档</a></li><li><a href="/project">项目</a></li><li><a href="/publication">论文</a></li><li><a href="/about">关于</a></li><li><a href="https://pan.baidu.com/s/1skOsE65">CV</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>身份证文本定位与切割算法实现</a></h3></div><div class="post-content"><p>最近项目需求(身份证信息自动识别)，需要对图像中的文本进行定位与提取，这…本汪真心不懂啊. 于是乎怀着忐忑的心情去找L老板唠嗑.</p>
<p><strong>[狗血剧情]</strong><br>本汪: 老师，这事没做过啊，不知道怎么做啊… (内心os: 您接项目能不能考虑下咱的技术储备啊)<br>L老板: 不会啊，去学啊! 网上找下资源和论文去吧.<br>本汪: 哦，好的… (当我没来)</p>
<p>于是乎在google上一番折腾，总算找到了一些相关文献. </p>
<p>可是，大部分Paper的应用场景是自然场景的文本提取(Detecting Text in Natural Scenes)，即从一张自然场景中提取文字片段(如从一张街道餐馆外景的照片中提取餐馆招牌文字). 好吧! 似乎不完全适用，不过咱先试试先.</p>
<p>文献记载的主要方法有两种:</p>
<ul>
<li>Maximally Stable Extremal Regions (MSER)，具体请戳这篇<a href="http://bit.ly/2wSQPao" target="_blank" rel="external">文章</a></li>
<li>Stroke Width Transform (SWT)，具体请戳这篇<a href="http://bit.ly/T6ewYn" target="_blank" rel="external">文章</a></li>
<li>基于滑动窗口和图像分类的方法. (果断放弃，我可不想自己去标数据!)</li>
</ul>
<p>接下来就是Coding实现啦. 又是github一顿翻，找了一些源码借鉴，勉强实现了MSER和SWT.</p>
<p>实际测试结果发现原始SWT和MSER效果都奇差啊! (内心崩溃中，仿佛能够遇见L老板那犀利的眼神)</p>
<p>好吧，你俩不是为”身份证文本提取”而生，可以原谅. 作为一只肯专研的科研汪，怎能这样坐以待毙呢. </p>
<p>于是乎又一顿搜索，咦！咱们的任务场景貌似可以用基本的图像处理+规则来弄啊!(果然简单才是美啊!没有人工就没有智能啊!)</p>
<p>于是乎崭新的天地出现啦!!! </p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>各位看官看了这么多废话，估计也烦了，为了让大家不拍本汪，必须是上代码的时候了.</p>
<p>这里我们首先新建一个detector.py文件，其中包含一个TextDector类.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="string">"""</span></div><div class="line">detector.py</div><div class="line">-------</div><div class="line">文字定位器，</div><div class="line">定位身份证中的文字区块.</div><div class="line">@author: Heng Ding</div><div class="line">@e-mail: hengding@whu.edu.cn</div><div class="line">"""</div><div class="line"><span class="keyword">import</span> cv2, numpy <span class="keyword">as</span> np</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextDetector</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="string">""" 文字定位器类 """</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, img_path)</span>:</span></div><div class="line">        self.img = cv2.imread(img_path)</div><div class="line">        self.resize_img = self.transform()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">transform</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">""" 归一化尺寸，将图片缩放到统一尺寸 """</span></div><div class="line">        h, w, c = np.shape(self.img)</div><div class="line">        f_h = <span class="number">1920</span></div><div class="line">        f_y = float(h) / <span class="number">1920</span></div><div class="line">        f_w = int(float(w) / f_y)</div><div class="line">        resize_img = cv2.resize(self.img, (f_w, f_h), interpolation=cv2.INTER_AREA)</div><div class="line">        <span class="keyword">return</span> resize_img</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hyp_parameters</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">""" 计算经验参数 """</span></div><div class="line">        h, w, c = np.shape(self.resize_img)</div><div class="line">        <span class="comment"># 文字区块最小最大面积</span></div><div class="line">        min_area, max_area = <span class="number">27</span>*<span class="number">27</span>, <span class="number">0.05</span> * h * w</div><div class="line">        <span class="comment"># 文字区块最小最大高度</span></div><div class="line">        min_h, max_h = <span class="number">50</span>, <span class="number">200</span></div><div class="line">        <span class="keyword">return</span> min_area, max_area, min_h, max_h</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_candidates</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">""" 返回候选文字区块坐标 """</span></div><div class="line"></div><div class="line">        <span class="comment"># 灰度化</span></div><div class="line">        gray = cv2.cvtColor(self.resize_img, cv2.COLOR_BGR2GRAY)</div><div class="line"></div><div class="line">        <span class="comment"># 二值化</span></div><div class="line">        _threshold = cv2.threshold(gray, <span class="number">100</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</div><div class="line"></div><div class="line">        <span class="comment"># 腐蚀</span></div><div class="line">        kernel = np.ones((<span class="number">27</span>, <span class="number">27</span>), np.uint8)</div><div class="line">        erosion = cv2.erode(_threshold, kernel, iterations = <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 轮廓检测</span></div><div class="line">        _, contours, hierarchy = cv2.findContours(erosion, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</div><div class="line"></div><div class="line">        <span class="comment"># 根据经验参数选取区域</span></div><div class="line">        candidate_boxes = []</div><div class="line">        min_area, max_area, min_h, max_h = self.hyp_parameters()</div><div class="line"></div><div class="line">        <span class="keyword">for</span> cnt <span class="keyword">in</span> contours:</div><div class="line">            x, y, w, h = cv2.boundingRect(cnt)</div><div class="line">            <span class="keyword">if</span> min_area &lt; cv2.contourArea(cnt) &lt; max_area <span class="keyword">and</span> min_h &lt; h &lt; max_h:</div><div class="line">                candidate_boxes.append((x,y,x+w,y+h))</div><div class="line"></div><div class="line">        <span class="keyword">return</span> candidate_boxes</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">split_candidates</span><span class="params">(self, box)</span>:</span></div><div class="line">        <span class="string">""" 候选区块切割 """</span></div><div class="line"></div><div class="line">        <span class="comment"># 灰度化</span></div><div class="line">        gray = cv2.cvtColor(self.resize_img, cv2.COLOR_BGR2GRAY)</div><div class="line">        <span class="comment"># 二值化</span></div><div class="line">        _threshold = cv2.threshold(gray, <span class="number">100</span>, <span class="number">255</span>, cv2.THRESH_BINARY)[<span class="number">1</span>]</div><div class="line"></div><div class="line">        <span class="comment"># 腐蚀</span></div><div class="line">        kernel = np.ones((<span class="number">3</span>, <span class="number">5</span>), np.uint8)</div><div class="line">        erosion = cv2.erode(_threshold, kernel, iterations = <span class="number">2</span>)</div><div class="line"></div><div class="line">        <span class="comment"># 获取区块对应腐蚀图像</span></div><div class="line">        x1, y1, x2, y2 = box</div><div class="line">        box_erosion = erosion[y1:y2, x1:x2]</div><div class="line"></div><div class="line">        <span class="comment"># 依据连续空白区域进行列切割</span></div><div class="line">        his = np.mean(box_erosion, axis=<span class="number">0</span>)</div><div class="line">        split_indexes, flag = [<span class="number">0</span>], <span class="keyword">True</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(his)):</div><div class="line">            c = his[i]</div><div class="line">            <span class="keyword">if</span> c != <span class="number">255</span> <span class="keyword">and</span> flag <span class="keyword">is</span> <span class="keyword">True</span>:</div><div class="line">                split_indexes.append(i)</div><div class="line">                flag = <span class="keyword">False</span></div><div class="line">            <span class="keyword">elif</span> c == <span class="number">255</span> <span class="keyword">and</span> flag <span class="keyword">is</span> <span class="keyword">False</span>:</div><div class="line">                split_indexes.append(i)</div><div class="line">                flag = <span class="keyword">True</span></div><div class="line">        split_indexes.append(len(his))</div><div class="line"></div><div class="line">        <span class="keyword">assert</span> len(split_indexes) % <span class="number">2</span> == <span class="number">0</span></div><div class="line"></div><div class="line">        t = [int((i+j)/<span class="number">2</span>) <span class="keyword">for</span> i,j <span class="keyword">in</span> zip(split_indexes[::<span class="number">2</span>],split_indexes[<span class="number">1</span>::<span class="number">2</span>])]</div><div class="line"></div><div class="line">        boxes = [(x1+t[i], y1, x1+t[i+<span class="number">1</span>], y2) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t)<span class="number">-1</span>) <span class="keyword">if</span> t[i+<span class="number">1</span>]-t[i]]</div><div class="line"></div><div class="line">        <span class="keyword">return</span> boxes</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_noisy</span><span class="params">(self, box)</span>:</span></div><div class="line">        <span class="string">""" 基于坐标规则判断是否属于人脸噪声区块 """</span></div><div class="line">        h, w, c = np.shape(self.resize_img)</div><div class="line">        x1, y1, x2, y2 = box</div><div class="line">        <span class="keyword">if</span> (x1+x2)/<span class="number">2</span> &gt; <span class="number">0.65</span>*w <span class="keyword">and</span> (y1+y2)/<span class="number">2</span> &lt; <span class="number">0.7</span>*h:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 初步查找候选区域</span></div><div class="line">        candidate_boxes = self.find_candidates()</div><div class="line"></div><div class="line">        <span class="comment"># 初步候选区域切割</span></div><div class="line">        split_boxes = []</div><div class="line">        <span class="keyword">for</span> candidate <span class="keyword">in</span> candidate_boxes:</div><div class="line">            <span class="keyword">if</span> candidate[<span class="number">2</span>]-candidate[<span class="number">0</span>] &gt; <span class="number">100</span>:</div><div class="line">                split_boxes += self.split_candidates(candidate)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                split_boxes += [candidate]</div><div class="line"></div><div class="line">        <span class="comment"># 屏蔽人脸区域噪音</span></div><div class="line">        final_boxes = []</div><div class="line">        <span class="keyword">for</span> box <span class="keyword">in</span> split_boxes:</div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.is_noisy(box):</div><div class="line">                final_boxes.append(box)</div><div class="line"></div><div class="line">        <span class="keyword">return</span> final_boxes</div></pre></td></tr></table></figure>
<p>该类使用方法如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">from</span> detector <span class="keyword">import</span> TextDetector</div><div class="line"></div><div class="line">d = TextDetector(<span class="string">"./imgs/ID2.jpg"</span>)</div><div class="line">boxes = d.detect()</div><div class="line"><span class="keyword">for</span> box <span class="keyword">in</span> boxes:</div><div class="line">    cv2.rectangle(d.resize_img, (box[<span class="number">0</span>], box[<span class="number">1</span>]), (box[<span class="number">2</span>], box[<span class="number">3</span>]), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">3</span>)</div><div class="line">cv2.imwrite(<span class="string">"./imgs/R2.jpg"</span>, d.resize_img)</div></pre></td></tr></table></figure>
<p>具体效果请看下图(测试身份证照片来源于百度图片，如有任何隐私问题，请私信本人)</p>
<div align="center"><br><img src="R1.jpg" style="width:60%; height:60%;"><br></div>

<div align="center"><br><img src="R2.jpg" style="width:60%; height:60%;"><br></div>

<p>完整代码(非商用版)请戳我的<a href="https://github.com/HengDing890/MserIdTextDetect" target="_blank" rel="external">Github</a></p>
<h3 id="高能吐槽"><a href="#高能吐槽" class="headerlink" title="高能吐槽"></a>高能吐槽</h3><p>最近有些童鞋私信咱，”这程序好多情况不work啊，通用性不是很好啊!能不能优化下?”</p>
<p>这让本汪咋说呢，我只能保证在我的应用场景下work:</p>
<ul>
<li>图片主体95%属于身份证，且基本无倾斜.(从背景中提取身份证区域，并进行倾斜矫正，这种成套解决方案恕不提供，开源的东西，也别要求别太高.)</li>
<li>图片质量高且清晰，首先至少要对焦清楚吧，其次你也别来个分辨率300*200的渣渣相片可好?</li>
<li>最后，真实应用场景可增加身份证边缘扫描对齐，从而保证图像质量.(别问我有没有代码，这玩意属于ios和android开发，且也不是啥秘密，你能google到!)</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-08-17</span><i class="fa fa-tag"></i><a href="/tags/文本定位/" title="文本定位" class="tag">文本定位 </a><a href="/tags/Python/" title="Python" class="tag">Python </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://yoursite.com/child/2017/08/17/基于MSER的文字定位与切割算法实现/,Heng Ding (丁恒),身份证文本定位与切割算法实现,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/08/17/置顶/" title="置顶贴(博文搬迁中,大量干货即将来袭)" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/08/16/排序学习原理简介及Python实践/" title="排序学习Python实践" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>